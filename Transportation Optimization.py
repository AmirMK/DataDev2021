import numpy as np
import pandas as pd
import itertools
import datetime

import pulp

import googlemaps
from geopy import distance as dst

import tabpy_client


def travel_cost_by_google(_arg1,_arg2,_arg3,real_time='off'):
    
    
    df= pd.DataFrame({'Cities':_arg1,'Lat':_arg2,'Long':_arg3})
    cost=[]
    for (i1, row1) in df.iterrows():      
        for (i2, row2) in df.iterrows():              
            LatOrigin = row1['Lat'] 
            LongOrigin = row1['Long']
            origins = (LatOrigin,LongOrigin)

      
            LatDest = row2['Lat']   # Save value as latitude
            LongDest = row2['Long'] # Save value as longitude
            destination = (LatDest,LongDest)
        
            if real_time=='off':
                result = ((dst.distance(origins, (destination)).miles)/60)*60
            else:
                #https://developers.google.com/maps/documentation/distance-matrix/overview
                #https://developers.google.com/maps/documentation/distance-matrix/get-api-key
                
                API_key = 'AI*****'#Get Google Maps API key
                gmaps = googlemaps.Client(key=API_key)
                result = gmaps.distance_matrix(origins, destination, mode='driving',
                                               departure_time=datetime.datetime.now())["rows"][0]
                ["elements"][0]['duration_in_traffic']['value']/60.57
            cost.append([row1['Cities'],row2['Cities'],result])
        
    cost = pd.DataFrame(cost,columns=['City1','City2','Distance'])    
    return(cost)


def optimization(_arg1,_arg2,_arg3,distance):
    n = (len(set(_arg1)))
    # Number of locations (store with surplus)
    customer_count = n

    # the number of vehicle
    vehicle_count = 1

    # the capacity of vehicle (total shortage need to be fulfilled)
    vehicle_capacity = _arg3[0]
    
    demand = _arg2
    dots = _arg1
        
    for vehicle_count in range(1,vehicle_count+1):
    
        # definition of LpProblem instance
        problem = pulp.LpProblem('CVRP', pulp.LpMinimize)

        # definition of variables which are 0/1
        x = [[[pulp.LpVariable('x%s_%s,%s'%(i,j,k), cat='Binary') if i != j 
               else None for k in range(vehicle_count)]for j in range(customer_count)] for i in range(customer_count)]

        # add objective function to minimize total travel time
        problem += pulp.lpSum(distance[i][j] * x[i][j][k] if i != j else 0
                          for k in range(vehicle_count) 
                          for j in range(customer_count) 
                          for i in range (customer_count))

        # constraints
        # foluma (2): Travel to each location no more than one time
        for j in range(1, customer_count):
            problem += pulp.lpSum(x[i][j][k] if i != j else 0 
                              for i in range(customer_count) 
                              for k in range(vehicle_count)) <= 1 

        # foluma (3): make sure there is just one vehicle 
        for k in range(vehicle_count):
            problem += pulp.lpSum(x[0][j][k] for j in range(1,customer_count)) == 1
            problem += pulp.lpSum(x[i][0][k] for i in range(1,customer_count)) == 1

        # foluma (4): Balanced inflow and outflow
        for k in range(vehicle_count):
            for j in range(customer_count):
                problem += pulp.lpSum(x[i][j][k] if i != j else 0 
                                  for i in range(customer_count)) -  pulp.lpSum(x[j][i][k] for i in range(customer_count)) == 0

        #foluma (5): Guarantee to get total shortage
        for k in range(vehicle_count):
            problem += pulp.lpSum(demand[j] * x[i][j][k] if i != j else 0 for i in range(customer_count)
                                  for j in range (1,customer_count)) >= vehicle_capacity 


        # fomula (6): Guarantee to avoid subtour in traveling path (disjoint subgraph navigation)
        subtours = []
        for i in range(2,customer_count):
             subtours += itertools.combinations(range(1,customer_count), i)

        for s in subtours:
            problem += pulp.lpSum(x[i][j][k] if i !=j else 0 for i, j in itertools.permutations(s,2) 
                                  for k in range(vehicle_count)) <= len(s) - 1

        if problem.solve() == 1:            
            break
    
    # Label cities with the optimized traveling order generated by the optimization model        
    order=dict()
    k=0
    sol=[]
    for i in range(customer_count):
        for j in range(customer_count):
            if i != j and pulp.value(x[i][j][0]) == 1: 
                sol.append([i,j])                
                order[dots[i]]=k
                k=k+1
    solution=[sol[0].copy()]
    i=0
    for s1 in solution:
        i=i+1
        if i >100: break
        for s2 in sol:
            if s1[1]==s2[0]:        
                solution.append(s2.copy())                        
                s2[0],s2[1]='NA','NA'    #NA will return for cities for which are not in the optimized path                    
                break
    i=0
    order=dict()
    for s in range(0,len(solution)-1):    
        order[dots[solution[s][0]]]=i
        i=i+1
    
    # Return the result in the same order as Tableau provided input data hene output matched with viz
    result=[]
    for e in _arg1:
        if e in order: 
            r = str(order[e])
        else: 
            r = 'NA'
        result.append(r)

    return(result)

#Wrapper function to pass main argument and generate optimized output
#Input: 
        #List of cities,  
        #List of surplus in the same ordr as cities
        #Total shortage
        #List of latitude in the same ordr as cities
        #List of longitude in the same ordr as cities
#Output:
    #Order of traveling path per city (NA will return for cities for which are not in the optimized path)
def route_optimization(_arg1,_arg2,_arg3,_arg4,_arg5):
    travel_cost = travel_cost_by_google(_arg1,_arg4,_arg5,real_time='off')        
    distance = travel_cost['Distance'].to_numpy().reshape((len(set(_arg1))), (len(set(_arg1))))
    result = optimization(_arg1,_arg2,_arg3,distance)    
    return(result)


#Build connection to TabPy server
connection = tabpy_client.Client('http://localhost:9004/')

#Deploye function 
connection.deploy('route_optimization',
                  route_optimization,
                  'Returns optimized route between cities', override = True)
